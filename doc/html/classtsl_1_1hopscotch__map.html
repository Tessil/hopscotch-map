<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hopscotch-map: tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hopscotch-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1hopscotch__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hopscotch__map_8h_source.html">hopscotch_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2eae39b540085051068d2c94d3054dd9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td></tr>
<tr class="separator:a2eae39b540085051068d2c94d3054dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115c1d91228c4e0f67571f449b323794"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a115c1d91228c4e0f67571f449b323794">mapped_type</a> = T</td></tr>
<tr class="separator:a115c1d91228c4e0f67571f449b323794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8775b4f4ca37f0ba1226b6ac8cf37b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td></tr>
<tr class="separator:aa8775b4f4ca37f0ba1226b6ac8cf37b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3b2278e6f731cdf4ac9b12ad62a71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td></tr>
<tr class="separator:a2ac3b2278e6f731cdf4ac9b12ad62a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746e99af4d2728c0284519b9d2beea88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a746e99af4d2728c0284519b9d2beea88">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td></tr>
<tr class="separator:a746e99af4d2728c0284519b9d2beea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45612102bc640807c27d9111b6b84888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a45612102bc640807c27d9111b6b84888">hasher</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td></tr>
<tr class="separator:a45612102bc640807c27d9111b6b84888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71848c7a83bde13a664d81ab29cfe009"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a71848c7a83bde13a664d81ab29cfe009">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td></tr>
<tr class="separator:a71848c7a83bde13a664d81ab29cfe009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1029454117f4dc02a2f8c565fd923ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td></tr>
<tr class="separator:aa1029454117f4dc02a2f8c565fd923ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148a927cbaa479eeb208e72f65a7cc6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a148a927cbaa479eeb208e72f65a7cc6a">reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a5f775e4fb024d454599f49464689ed52">ht::reference</a></td></tr>
<tr class="separator:a148a927cbaa479eeb208e72f65a7cc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8b308813e7b74a4dab48858e961110"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a5f8b308813e7b74a4dab48858e961110">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8e9b3264646b2ed848b1cab77261c292">ht::const_reference</a></td></tr>
<tr class="separator:a5f8b308813e7b74a4dab48858e961110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10beb351b4ff9c9702a13b6e5df659f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a10beb351b4ff9c9702a13b6e5df659f7">pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#acbaf548937735aaaacf7d1ac276f9b6d">ht::pointer</a></td></tr>
<tr class="separator:a10beb351b4ff9c9702a13b6e5df659f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce17bf22290aead159b36b3fc54e78b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a6ce17bf22290aead159b36b3fc54e78b">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a34cefbaff6455385ddf83ca2fe373f43">ht::const_pointer</a></td></tr>
<tr class="separator:a6ce17bf22290aead159b36b3fc54e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f52fac14aebb6fa6a86264d0973db2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td></tr>
<tr class="separator:a60f52fac14aebb6fa6a86264d0973db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f7dbb7b85f2d41b9bf81ab7d5b474f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td></tr>
<tr class="separator:ab1f7dbb7b85f2d41b9bf81ab7d5b474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a447530a7b92ad7ed2e902302e10e91b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a447530a7b92ad7ed2e902302e10e91b6">hopscotch_map</a> ()</td></tr>
<tr class="separator:a447530a7b92ad7ed2e902302e10e91b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b5f0e68b9f92d2732c3fa74cdcd22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a5b3b5f0e68b9f92d2732c3fa74cdcd22">hopscotch_map</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a5b3b5f0e68b9f92d2732c3fa74cdcd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a370299f055b767aa8bd2e884f6f78a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a7a370299f055b767aa8bd2e884f6f78a">hopscotch_map</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a7a370299f055b767aa8bd2e884f6f78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49f9a4593db3799f30691547f12569c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ac49f9a4593db3799f30691547f12569c">hopscotch_map</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ac49f9a4593db3799f30691547f12569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bc1495e4ea36f2cb429b058e847122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae4bc1495e4ea36f2cb429b058e847122">hopscotch_map</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:ae4bc1495e4ea36f2cb429b058e847122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4b191e8bea5b17ddded13a532eded7"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a7b4b191e8bea5b17ddded13a532eded7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a7b4b191e8bea5b17ddded13a532eded7">hopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a7b4b191e8bea5b17ddded13a532eded7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bd9fdd26e3984602b456aa0e50ba67"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a00bd9fdd26e3984602b456aa0e50ba67"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a00bd9fdd26e3984602b456aa0e50ba67">hopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a00bd9fdd26e3984602b456aa0e50ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db9d26abc385eebc73c380a6cf95242"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a4db9d26abc385eebc73c380a6cf95242"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a4db9d26abc385eebc73c380a6cf95242">hopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a4db9d26abc385eebc73c380a6cf95242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb86e389b533f4eec6b7d0a77847881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a7eb86e389b533f4eec6b7d0a77847881">hopscotch_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; init, <a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a7eb86e389b533f4eec6b7d0a77847881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09cc7d50fcaae8a841672b8f6054e29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ac09cc7d50fcaae8a841672b8f6054e29">hopscotch_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; init, <a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ac09cc7d50fcaae8a841672b8f6054e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f411a4dfd00bcbefcd6ca0542b16ee8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a9f411a4dfd00bcbefcd6ca0542b16ee8">hopscotch_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; init, <a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a9f411a4dfd00bcbefcd6ca0542b16ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2df485874c9bf497d5b334a2737e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a5a2df485874c9bf497d5b334a2737e83">operator=</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a5a2df485874c9bf497d5b334a2737e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff56f4907ab6625b61c64fbf7df92bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#adff56f4907ab6625b61c64fbf7df92bd">get_allocator</a> () const</td></tr>
<tr class="separator:adff56f4907ab6625b61c64fbf7df92bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427075830599fc53bcd649b4a14d5bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a427075830599fc53bcd649b4a14d5bde">begin</a> () noexcept</td></tr>
<tr class="separator:a427075830599fc53bcd649b4a14d5bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441ea957f3a7fe842867a289742c3d0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a441ea957f3a7fe842867a289742c3d0f">begin</a> () const noexcept</td></tr>
<tr class="separator:a441ea957f3a7fe842867a289742c3d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4406ad14b90cd52b766d551029e88cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a4406ad14b90cd52b766d551029e88cb7">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a4406ad14b90cd52b766d551029e88cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3f3585aa1f4c830ff7e8eced1e8a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a2e3f3585aa1f4c830ff7e8eced1e8a6f">end</a> () noexcept</td></tr>
<tr class="separator:a2e3f3585aa1f4c830ff7e8eced1e8a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43571f72a4b43740ea45b1e219da3013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a43571f72a4b43740ea45b1e219da3013">end</a> () const noexcept</td></tr>
<tr class="separator:a43571f72a4b43740ea45b1e219da3013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27dbe412d061b26576a36936825949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a0e27dbe412d061b26576a36936825949">cend</a> () const noexcept</td></tr>
<tr class="separator:a0e27dbe412d061b26576a36936825949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b459d21ab54d516812206a481806b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae41b459d21ab54d516812206a481806b">empty</a> () const noexcept</td></tr>
<tr class="separator:ae41b459d21ab54d516812206a481806b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4927ca3c49b36756a1d4ade22ac4c59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a4927ca3c49b36756a1d4ade22ac4c59f">size</a> () const noexcept</td></tr>
<tr class="separator:a4927ca3c49b36756a1d4ade22ac4c59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae004c2c0b10d1fb1942d5d78b7461aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae004c2c0b10d1fb1942d5d78b7461aee">max_size</a> () const noexcept</td></tr>
<tr class="separator:ae004c2c0b10d1fb1942d5d78b7461aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa591920de994ce89ec87cf0be5b84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a1aa591920de994ce89ec87cf0be5b84b">clear</a> () noexcept</td></tr>
<tr class="separator:a1aa591920de994ce89ec87cf0be5b84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a483423694515d6af1b75bc4fe9d89d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a9a483423694515d6af1b75bc4fe9d89d">insert</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;value)</td></tr>
<tr class="separator:a9a483423694515d6af1b75bc4fe9d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0397845e9f1ebfc56d60dd9c7de7f36a"><td class="memTemplParams" colspan="2">template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0397845e9f1ebfc56d60dd9c7de7f36a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a0397845e9f1ebfc56d60dd9c7de7f36a">insert</a> (P &amp;&amp;value)</td></tr>
<tr class="separator:a0397845e9f1ebfc56d60dd9c7de7f36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5206af5bde90107b72dbd6b2a910614b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a5206af5bde90107b72dbd6b2a910614b">insert</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a5206af5bde90107b72dbd6b2a910614b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dd9d1f9df86cceb2b4b910de7b959e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a11dd9d1f9df86cceb2b4b910de7b959e">insert</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, const <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;value)</td></tr>
<tr class="separator:a11dd9d1f9df86cceb2b4b910de7b959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34c3cdf30912908d289fde716cd1892"><td class="memTemplParams" colspan="2">template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab34c3cdf30912908d289fde716cd1892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab34c3cdf30912908d289fde716cd1892">insert</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, P &amp;&amp;value)</td></tr>
<tr class="separator:ab34c3cdf30912908d289fde716cd1892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac194248ad6b5d71478beb5867b0e7f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ac194248ad6b5d71478beb5867b0e7f56">insert</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:ac194248ad6b5d71478beb5867b0e7f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50df14a0a6829e7b8bf4cf96287cd7fa"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a50df14a0a6829e7b8bf4cf96287cd7fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a50df14a0a6829e7b8bf4cf96287cd7fa">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a50df14a0a6829e7b8bf4cf96287cd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fcf313641cc7af76b1457867c16fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a13fcf313641cc7af76b1457867c16fe6">insert</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a13fcf313641cc7af76b1457867c16fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62be531541a9a4b71aa44e8f3894d964"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a62be531541a9a4b71aa44e8f3894d964"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a62be531541a9a4b71aa44e8f3894d964">insert_or_assign</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a62be531541a9a4b71aa44e8f3894d964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0c5bb7986c0eb12fc6468d04d9acee"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a5c0c5bb7986c0eb12fc6468d04d9acee"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a5c0c5bb7986c0eb12fc6468d04d9acee">insert_or_assign</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a5c0c5bb7986c0eb12fc6468d04d9acee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6b3065037c40dabf7d415b1ca1d7d"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a30d6b3065037c40dabf7d415b1ca1d7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a30d6b3065037c40dabf7d415b1ca1d7d">insert_or_assign</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a30d6b3065037c40dabf7d415b1ca1d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df8328a9edf3f97fc25023a8462f6e1"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a5df8328a9edf3f97fc25023a8462f6e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a5df8328a9edf3f97fc25023a8462f6e1">insert_or_assign</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a5df8328a9edf3f97fc25023a8462f6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71a4607bb7d0ddff2ba6a58ac15e235"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab71a4607bb7d0ddff2ba6a58ac15e235"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab71a4607bb7d0ddff2ba6a58ac15e235">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab71a4607bb7d0ddff2ba6a58ac15e235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae502f80e454fde413806663658847c4e"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae502f80e454fde413806663658847c4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae502f80e454fde413806663658847c4e">emplace_hint</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae502f80e454fde413806663658847c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48fc0a8849089b3f21496a379db9a4b"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:af48fc0a8849089b3f21496a379db9a4b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#af48fc0a8849089b3f21496a379db9a4b">try_emplace</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:af48fc0a8849089b3f21496a379db9a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96e205aa0d75e1d52ff5243596d406a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab96e205aa0d75e1d52ff5243596d406a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab96e205aa0d75e1d52ff5243596d406a">try_emplace</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab96e205aa0d75e1d52ff5243596d406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14709e833263ea6e69f52af09985aba0"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a14709e833263ea6e69f52af09985aba0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a14709e833263ea6e69f52af09985aba0">try_emplace</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a14709e833263ea6e69f52af09985aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a6faa967e500b0a882ffb572b2b69"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae56a6faa967e500b0a882ffb572b2b69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae56a6faa967e500b0a882ffb572b2b69">try_emplace</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae56a6faa967e500b0a882ffb572b2b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ee0d0bff7224e9e130150ff183bdeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a26ee0d0bff7224e9e130150ff183bdeb">erase</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> pos)</td></tr>
<tr class="separator:a26ee0d0bff7224e9e130150ff183bdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4ba064d2ead6b7e9d20e9f4902a1ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a2e4ba064d2ead6b7e9d20e9f4902a1ca">erase</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> pos)</td></tr>
<tr class="separator:a2e4ba064d2ead6b7e9d20e9f4902a1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3416ddb5a149fffa931c10439a074d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a3416ddb5a149fffa931c10439a074d41">erase</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> first, <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> last)</td></tr>
<tr class="separator:a3416ddb5a149fffa931c10439a074d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e093bee93337aa1e89a610d53764824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a0e093bee93337aa1e89a610d53764824">erase</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;key)</td></tr>
<tr class="separator:a0e093bee93337aa1e89a610d53764824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741fb9bd476e91d66237c27e9260d464"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a741fb9bd476e91d66237c27e9260d464"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a741fb9bd476e91d66237c27e9260d464">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:a741fb9bd476e91d66237c27e9260d464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f88bfcbc06111a158ed7afbe004a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a51f88bfcbc06111a158ed7afbe004a7b">swap</a> (<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;other)</td></tr>
<tr class="separator:a51f88bfcbc06111a158ed7afbe004a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13329433e2fc7cd600087e60cf48ad9"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ac13329433e2fc7cd600087e60cf48ad9">at</a> (const Key &amp;key)</td></tr>
<tr class="separator:ac13329433e2fc7cd600087e60cf48ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ff28c5675d6bb92dab7b2654ff1d8b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a32ff28c5675d6bb92dab7b2654ff1d8b">at</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a32ff28c5675d6bb92dab7b2654ff1d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ef69cca03c4aa7876e214aff88b493"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa4ef69cca03c4aa7876e214aff88b493"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aa4ef69cca03c4aa7876e214aff88b493">at</a> (const K &amp;key)</td></tr>
<tr class="separator:aa4ef69cca03c4aa7876e214aff88b493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f81ae42f4a16add1d766d69aaabafab"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4f81ae42f4a16add1d766d69aaabafab"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a4f81ae42f4a16add1d766d69aaabafab">at</a> (const K &amp;key) const</td></tr>
<tr class="separator:a4f81ae42f4a16add1d766d69aaabafab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e33e27531a19c7fd948fe883a07f17"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab6e33e27531a19c7fd948fe883a07f17">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="separator:ab6e33e27531a19c7fd948fe883a07f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcd4b3f85dfcc12e462a9d9db1ed171"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a7bcd4b3f85dfcc12e462a9d9db1ed171">operator[]</a> (Key &amp;&amp;key)</td></tr>
<tr class="separator:a7bcd4b3f85dfcc12e462a9d9db1ed171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a88790c4f7555a99e2abc12a562bd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a0a88790c4f7555a99e2abc12a562bd34">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a0a88790c4f7555a99e2abc12a562bd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a31a7772dfe4f6085e8d87ba423c33"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9a31a7772dfe4f6085e8d87ba423c33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae9a31a7772dfe4f6085e8d87ba423c33">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:ae9a31a7772dfe4f6085e8d87ba423c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd20a86de3dbedd12c68e62703067138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#afd20a86de3dbedd12c68e62703067138">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:afd20a86de3dbedd12c68e62703067138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09cbacc3b8fb8c99a06814df0b86c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aa09cbacc3b8fb8c99a06814df0b86c4b">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:aa09cbacc3b8fb8c99a06814df0b86c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc9cfa53edaae65f26aa35e1aa6b7d6"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aecc9cfa53edaae65f26aa35e1aa6b7d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aecc9cfa53edaae65f26aa35e1aa6b7d6">find</a> (const K &amp;key)</td></tr>
<tr class="separator:aecc9cfa53edaae65f26aa35e1aa6b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9ad2d6a7584d98ad2e06e5b880d0d8"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aec9ad2d6a7584d98ad2e06e5b880d0d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aec9ad2d6a7584d98ad2e06e5b880d0d8">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:aec9ad2d6a7584d98ad2e06e5b880d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067d12d4993e2c1c86a5c66d28b1850d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a067d12d4993e2c1c86a5c66d28b1850d">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:a067d12d4993e2c1c86a5c66d28b1850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bd596d405490fc3eafe5f17d66690c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ad3bd596d405490fc3eafe5f17d66690c">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:ad3bd596d405490fc3eafe5f17d66690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00c7a45085c513c4344d4c840cdfc2b"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab00c7a45085c513c4344d4c840cdfc2b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab00c7a45085c513c4344d4c840cdfc2b">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:ab00c7a45085c513c4344d4c840cdfc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08ce089dc1f95b945d44656f2e47b2"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aca08ce089dc1f95b945d44656f2e47b2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aca08ce089dc1f95b945d44656f2e47b2">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:aca08ce089dc1f95b945d44656f2e47b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd0daab184ba503b801be16d5077eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aebd0daab184ba503b801be16d5077eb7">bucket_count</a> () const</td></tr>
<tr class="separator:aebd0daab184ba503b801be16d5077eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae391a0f4c83b6ab9c7503b4ca335b370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae391a0f4c83b6ab9c7503b4ca335b370">max_bucket_count</a> () const</td></tr>
<tr class="separator:ae391a0f4c83b6ab9c7503b4ca335b370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2674047296b5b925d24c80df8e35bd0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ac2674047296b5b925d24c80df8e35bd0">load_factor</a> () const</td></tr>
<tr class="separator:ac2674047296b5b925d24c80df8e35bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48f17ccd7760fde3b2a666823741142"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#aa48f17ccd7760fde3b2a666823741142">max_load_factor</a> () const</td></tr>
<tr class="separator:aa48f17ccd7760fde3b2a666823741142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a2b90171e6152f5fd534cbf510ea40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ab4a2b90171e6152f5fd534cbf510ea40">max_load_factor</a> (float ml)</td></tr>
<tr class="separator:ab4a2b90171e6152f5fd534cbf510ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433e34d63203db277b366a872b7b77a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a433e34d63203db277b366a872b7b77a2">rehash</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#a0a88790c4f7555a99e2abc12a562bd34">count</a>)</td></tr>
<tr class="separator:a433e34d63203db277b366a872b7b77a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a10db186d798b8c75d9803b4131f159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a0a10db186d798b8c75d9803b4131f159">reserve</a> (<a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html#a0a88790c4f7555a99e2abc12a562bd34">count</a>)</td></tr>
<tr class="separator:a0a10db186d798b8c75d9803b4131f159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22024c61aa478aff2b9dc601801f3047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a45612102bc640807c27d9111b6b84888">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a22024c61aa478aff2b9dc601801f3047">hash_function</a> () const</td></tr>
<tr class="separator:a22024c61aa478aff2b9dc601801f3047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7236bc7221f302284165e0ab4e2c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a71848c7a83bde13a664d81ab29cfe009">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a6b7236bc7221f302284165e0ab4e2c2c">key_eq</a> () const</td></tr>
<tr class="separator:a6b7236bc7221f302284165e0ab4e2c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af540aaceecfd3809d0c8d42d6fd2a4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#af540aaceecfd3809d0c8d42d6fd2a4d7">overflow_size</a> () const noexcept</td></tr>
<tr class="separator:af540aaceecfd3809d0c8d42d6fd2a4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a998b5b063e0895c40a81de5e54034a0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a998b5b063e0895c40a81de5e54034a0f">operator==</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;rhs)</td></tr>
<tr class="separator:a998b5b063e0895c40a81de5e54034a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d662876f88352fe68f0461d997e35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#a448d662876f88352fe68f0461d997e35">operator!=</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;rhs)</td></tr>
<tr class="separator:a448d662876f88352fe68f0461d997e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae939cc5e813994c09fa4e5cd687e1f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map.html#ae939cc5e813994c09fa4e5cd687e1f5c">swap</a> (<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;lhs, <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;rhs)</td></tr>
<tr class="separator:ae939cc5e813994c09fa4e5cd687e1f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::power_of_two_growth_policy&gt;<br />
class tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;</h3>

<p>Implementation of a hash map using the hopscotch hashing algorithm.</p>
<p>The Key and the value T must be either nothrow move-constructible, copy-constuctible or both.</p>
<p>The size of the neighborhood (NeighborhoodSize) must be &gt; 0 and &lt;= 62 if StoreHash is false. When StoreHash is true, 32-bits of the hash will be stored alongside the neighborhood limiting the NeighborhoodSize to &lt;= 30. There is no memory usage difference between 'NeighborhoodSize 62; StoreHash false' and 'NeighborhoodSize 30; StoreHash true'.</p>
<p>Storing the hash may improve performance on insert during the rehash process if the hash takes time to compute. It may also improve read performance if the KeyEqual function takes time (or incurs a cache-miss). If used with simple Hash and KeyEqual it may slow things down.</p>
<p>GrowthPolicy defines how the map grows and consequently how a hash value is mapped to a bucket. By default the map uses <a class="el" href="classtsl_1_1power__of__two__growth__policy.html">tsl::power_of_two_growth_policy</a>. This policy keeps the number of buckets to a power of two and uses a mask to map the hash to a bucket instead of the slow modulo. You may define your own growth policy, check <a class="el" href="classtsl_1_1power__of__two__growth__policy.html">tsl::power_of_two_growth_policy</a> for the interface.</p>
<p>If the destructors of Key or T throw an exception, behaviour of the class is undefined.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators.</li>
<li>insert, emplace, emplace_hint, operator[]: if there is an effective insert, invalidate the iterators if a displacement is needed to resolve a collision (which mean that most of the time, insert will invalidate the iterators). Or if there is a rehash.</li>
<li>erase: iterator on the erased element is the only one which become invalid. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa1029454117f4dc02a2f8c565fd923ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1029454117f4dc02a2f8c565fd923ce">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1f7dbb7b85f2d41b9bf81ab7d5b474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce17bf22290aead159b36b3fc54e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce17bf22290aead159b36b3fc54e78b">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a6ce17bf22290aead159b36b3fc54e78b">const_pointer</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a34cefbaff6455385ddf83ca2fe373f43">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f8b308813e7b74a4dab48858e961110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8b308813e7b74a4dab48858e961110">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a5f8b308813e7b74a4dab48858e961110">const_reference</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8e9b3264646b2ed848b1cab77261c292">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a746e99af4d2728c0284519b9d2beea88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746e99af4d2728c0284519b9d2beea88">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a746e99af4d2728c0284519b9d2beea88">difference_type</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45612102bc640807c27d9111b6b84888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45612102bc640807c27d9111b6b84888">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a45612102bc640807c27d9111b6b84888">hasher</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60f52fac14aebb6fa6a86264d0973db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f52fac14aebb6fa6a86264d0973db2">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71848c7a83bde13a664d81ab29cfe009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71848c7a83bde13a664d81ab29cfe009">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a71848c7a83bde13a664d81ab29cfe009">key_equal</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eae39b540085051068d2c94d3054dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae39b540085051068d2c94d3054dd9">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a115c1d91228c4e0f67571f449b323794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115c1d91228c4e0f67571f449b323794">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a115c1d91228c4e0f67571f449b323794">mapped_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10beb351b4ff9c9702a13b6e5df659f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10beb351b4ff9c9702a13b6e5df659f7">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a10beb351b4ff9c9702a13b6e5df659f7">pointer</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#acbaf548937735aaaacf7d1ac276f9b6d">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a148a927cbaa479eeb208e72f65a7cc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148a927cbaa479eeb208e72f65a7cc6a">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a148a927cbaa479eeb208e72f65a7cc6a">reference</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a5f775e4fb024d454599f49464689ed52">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ac3b2278e6f731cdf4ac9b12ad62a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8775b4f4ca37f0ba1226b6ac8cf37b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a447530a7b92ad7ed2e902302e10e91b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447530a7b92ad7ed2e902302e10e91b6">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3b5f0e68b9f92d2732c3fa74cdcd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3b5f0e68b9f92d2732c3fa74cdcd22">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a370299f055b767aa8bd2e884f6f78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a370299f055b767aa8bd2e884f6f78a">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac49f9a4593db3799f30691547f12569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49f9a4593db3799f30691547f12569c">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4bc1495e4ea36f2cb429b058e847122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bc1495e4ea36f2cb429b058e847122">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b4b191e8bea5b17ddded13a532eded7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4b191e8bea5b17ddded13a532eded7">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00bd9fdd26e3984602b456aa0e50ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bd9fdd26e3984602b456aa0e50ba67">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db9d26abc385eebc73c380a6cf95242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db9d26abc385eebc73c380a6cf95242">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eb86e389b533f4eec6b7d0a77847881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb86e389b533f4eec6b7d0a77847881">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac09cc7d50fcaae8a841672b8f6054e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09cc7d50fcaae8a841672b8f6054e29">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f411a4dfd00bcbefcd6ca0542b16ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f411a4dfd00bcbefcd6ca0542b16ee8">&#9670;&nbsp;</a></span>hopscotch_map() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac13329433e2fc7cd600087e60cf48ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13329433e2fc7cd600087e60cf48ad9">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32ff28c5675d6bb92dab7b2654ff1d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ff28c5675d6bb92dab7b2654ff1d8b">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4ef69cca03c4aa7876e214aff88b493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ef69cca03c4aa7876e214aff88b493">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a4f81ae42f4a16add1d766d69aaabafab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f81ae42f4a16add1d766d69aaabafab">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a427075830599fc53bcd649b4a14d5bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427075830599fc53bcd649b4a14d5bde">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a441ea957f3a7fe842867a289742c3d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441ea957f3a7fe842867a289742c3d0f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd0daab184ba503b801be16d5077eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd0daab184ba503b801be16d5077eb7">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4406ad14b90cd52b766d551029e88cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4406ad14b90cd52b766d551029e88cb7">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e27dbe412d061b26576a36936825949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e27dbe412d061b26576a36936825949">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa591920de994ce89ec87cf0be5b84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa591920de994ce89ec87cf0be5b84b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a88790c4f7555a99e2abc12a562bd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a88790c4f7555a99e2abc12a562bd34">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9a31a7772dfe4f6085e8d87ba423c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a31a7772dfe4f6085e8d87ba423c33">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ab71a4607bb7d0ddff2ba6a58ac15e235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71a4607bb7d0ddff2ba6a58ac15e235">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="ae502f80e454fde413806663658847c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae502f80e454fde413806663658847c4e">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="ae41b459d21ab54d516812206a481806b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b459d21ab54d516812206a481806b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e3f3585aa1f4c830ff7e8eced1e8a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3f3585aa1f4c830ff7e8eced1e8a6f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43571f72a4b43740ea45b1e219da3013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43571f72a4b43740ea45b1e219da3013">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a067d12d4993e2c1c86a5c66d28b1850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067d12d4993e2c1c86a5c66d28b1850d">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3bd596d405490fc3eafe5f17d66690c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bd596d405490fc3eafe5f17d66690c">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab00c7a45085c513c4344d4c840cdfc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00c7a45085c513c4344d4c840cdfc2b">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aca08ce089dc1f95b945d44656f2e47b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca08ce089dc1f95b945d44656f2e47b2">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a26ee0d0bff7224e9e130150ff183bdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ee0d0bff7224e9e130150ff183bdeb">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e4ba064d2ead6b7e9d20e9f4902a1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4ba064d2ead6b7e9d20e9f4902a1ca">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3416ddb5a149fffa931c10439a074d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3416ddb5a149fffa931c10439a074d41">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e093bee93337aa1e89a610d53764824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e093bee93337aa1e89a610d53764824">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a741fb9bd476e91d66237c27e9260d464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741fb9bd476e91d66237c27e9260d464">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="afd20a86de3dbedd12c68e62703067138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd20a86de3dbedd12c68e62703067138">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa09cbacc3b8fb8c99a06814df0b86c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09cbacc3b8fb8c99a06814df0b86c4b">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc9cfa53edaae65f26aa35e1aa6b7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc9cfa53edaae65f26aa35e1aa6b7d6">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aec9ad2d6a7584d98ad2e06e5b880d0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9ad2d6a7584d98ad2e06e5b880d0d8">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="adff56f4907ab6625b61c64fbf7df92bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff56f4907ab6625b61c64fbf7df92bd">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22024c61aa478aff2b9dc601801f3047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22024c61aa478aff2b9dc601801f3047">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a45612102bc640807c27d9111b6b84888">hasher</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a483423694515d6af1b75bc4fe9d89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a483423694515d6af1b75bc4fe9d89d">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0397845e9f1ebfc56d60dd9c7de7f36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0397845e9f1ebfc56d60dd9c7de7f36a">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5206af5bde90107b72dbd6b2a910614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5206af5bde90107b72dbd6b2a910614b">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11dd9d1f9df86cceb2b4b910de7b959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dd9d1f9df86cceb2b4b910de7b959e">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab34c3cdf30912908d289fde716cd1892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34c3cdf30912908d289fde716cd1892">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp;&gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac194248ad6b5d71478beb5867b0e7f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac194248ad6b5d71478beb5867b0e7f56">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50df14a0a6829e7b8bf4cf96287cd7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50df14a0a6829e7b8bf4cf96287cd7fa">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13fcf313641cc7af76b1457867c16fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fcf313641cc7af76b1457867c16fe6">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62be531541a9a4b71aa44e8f3894d964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62be531541a9a4b71aa44e8f3894d964">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c0c5bb7986c0eb12fc6468d04d9acee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0c5bb7986c0eb12fc6468d04d9acee">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d6b3065037c40dabf7d415b1ca1d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d6b3065037c40dabf7d415b1ca1d7d">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5df8328a9edf3f97fc25023a8462f6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df8328a9edf3f97fc25023a8462f6e1">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b7236bc7221f302284165e0ab4e2c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7236bc7221f302284165e0ab4e2c2c">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a71848c7a83bde13a664d81ab29cfe009">key_equal</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2674047296b5b925d24c80df8e35bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2674047296b5b925d24c80df8e35bd0">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae391a0f4c83b6ab9c7503b4ca335b370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae391a0f4c83b6ab9c7503b4ca335b370">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa48f17ccd7760fde3b2a666823741142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48f17ccd7760fde3b2a666823741142">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4a2b90171e6152f5fd534cbf510ea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a2b90171e6152f5fd534cbf510ea40">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae004c2c0b10d1fb1942d5d78b7461aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae004c2c0b10d1fb1942d5d78b7461aee">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a2df485874c9bf497d5b334a2737e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2df485874c9bf497d5b334a2737e83">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1hopscotch__map.html#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6e33e27531a19c7fd948fe883a07f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e33e27531a19c7fd948fe883a07f17">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bcd4b3f85dfcc12e462a9d9db1ed171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcd4b3f85dfcc12e462a9d9db1ed171">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af540aaceecfd3809d0c8d42d6fd2a4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af540aaceecfd3809d0c8d42d6fd2a4d7">&#9670;&nbsp;</a></span>overflow_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a433e34d63203db277b366a872b7b77a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433e34d63203db277b366a872b7b77a2">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a10db186d798b8c75d9803b4131f159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a10db186d798b8c75d9803b4131f159">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4927ca3c49b36756a1d4ade22ac4c59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4927ca3c49b36756a1d4ade22ac4c59f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51f88bfcbc06111a158ed7afbe004a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f88bfcbc06111a158ed7afbe004a7b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af48fc0a8849089b3f21496a379db9a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48fc0a8849089b3f21496a379db9a4b">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab96e205aa0d75e1d52ff5243596d406a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96e205aa0d75e1d52ff5243596d406a">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14709e833263ea6e69f52af09985aba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14709e833263ea6e69f52af09985aba0">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae56a6faa967e500b0a882ffb572b2b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a6faa967e500b0a882ffb572b2b69">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a448d662876f88352fe68f0461d997e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d662876f88352fe68f0461d997e35">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a998b5b063e0895c40a81de5e54034a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998b5b063e0895c40a81de5e54034a0f">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae939cc5e813994c09fa4e5cd687e1f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae939cc5e813994c09fa4e5cd687e1f5c">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::power_of_two_growth_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="hopscotch__map_8h_source.html">hopscotch_map.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
